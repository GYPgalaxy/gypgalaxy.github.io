
<!DOCTYPE html>
<html lang="cn">
    <head>
        <meta charset="utf-8" />
        <title>go面经 | 银飒沓流星</title>
        <meta name="author" content="高亚鹏" />
        <meta name="description" content="" />
        <meta name="keywords" content="golang,python,deep learning,nlp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>银飒沓流星</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;银飒沓流星</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>go面经</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/17
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/go/" style="color: #ffa2c4">go</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E9%9D%A2%E7%BB%8F/" style="color: #00bcd4">面经</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><ol>
<li>&#x3D; 和 :&#x3D; 的区别？</li>
</ol>
<pre><code class="go">:= 声明+赋值
= 仅赋值

var foo int
foo = 10
// 等价于
foo := 10
</code></pre>
<ol start="2">
<li>指针的作用</li>
</ol>
<pre><code class="go">指针用来保存变量的地址。

例如
var x =  5
var p *int = &amp;x
fmt.Printf(&quot;x = %d&quot;,  *p) // x 可以用 *p 访问

* 运算符，也称为解引用运算符，用于访问地址中的值。
＆运算符，也称为地址运算符，用于返回变量的地址。
</code></pre>
<ol start="3">
<li>Go 有异常类型吗？</li>
</ol>
<pre><code class="go">Go 没有异常类型，只有错误类型（Error），通常使用返回值来表示异常状态。


f, err := os.Open(&quot;test.txt&quot;)
if err != nil &#123;
    log.Fatal(err)
&#125;
</code></pre>
<ol start="4">
<li>什么是协程（Goroutine）</li>
</ol>
<pre><code class="go">Goroutine 是与其他函数或方法同时运行的函数或方法。
Goroutines 可以被认为是轻量级的线程。 
与线程相比，创建 Goroutine 的开销很小。 
Go应用程序同时运行数千个 Goroutine 是非常常见的做法。
</code></pre>
<ol start="5">
<li>如何高效地拼接字符串</li>
</ol>
<pre><code class="go">Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。
如果需要拼接多次，应使用 `strings.Builder`，最小化内存拷贝次数。

var str strings.Builder
for i := 0;i&lt;1000;i++&#123;
    str.WriteString(&quot;a&quot;)
&#125;
fmt.Println(str.String())
</code></pre>
<ol start="6">
<li>什么是 rune 类型</li>
</ol>
<pre><code class="go">ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。

Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 语 和 言 使用 UTF-8 编码后各占 3 个 byte，因此 len(&quot;Go语言&quot;) 等于 8，当然我们也可以将字符串转换为 rune 序列。


fmt.Println(len(&quot;Go语言&quot;)) // 8
fmt.Println(len([]rune(&quot;Go语言&quot;))) // 4
</code></pre>
<ol start="7">
<li>如何判断 map 中是否包含某个 key ？</li>
</ol>
<pre><code class="go">if val, ok := dict[&quot;foo&quot;]; ok &#123;
    //do something here
&#125;

dict[&quot;foo&quot;] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key &quot;foo&quot;，val 将被赋予 &quot;foo&quot; 对应的值。
</code></pre>
<ol start="8">
<li>Go 支持默认参数或可选参数吗？</li>
</ol>
<pre><code class="go">Go 语言不支持可选参数（python 支持），也不支持方法重载（java支持）。
</code></pre>
<ol start="9">
<li>defer 的执行顺序</li>
</ol>
<pre><code class="go">- 多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。
- defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。


func test() int &#123;
    i := 0
    defer func() &#123;
        fmt.Println(&quot;defer1&quot;)
    &#125;()
    defer func() &#123;
        i += 1
        fmt.Println(&quot;defer2&quot;)
    &#125;()
    return i
&#125;

func main() &#123;
    fmt.Println(&quot;return&quot;, test())
&#125;
// defer2
// defer1
// return 0

这个例子中，可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。那如果是有名的返回值呢？


func test() (i int) &#123;
    i = 0
    defer func() &#123;
        i += 1
        fmt.Println(&quot;defer2&quot;)
    &#125;()
    return i
&#125;

func main() &#123;
    fmt.Println(&quot;return&quot;, test())
&#125;
// defer2
// return 1

这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。
</code></pre>
<ol start="10">
<li>如何交换 2 个变量的值？</li>
</ol>
<pre><code class="go">a,b := 1,2
a,b = b,a
</code></pre>
<ol start="11">
<li>Go 语言 tag 的用处？</li>
</ol>
<pre><code class="go">tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。

例如：
package main

import &quot;fmt&quot;
import &quot;encoding/json&quot;

type Stu struct &#123;
    Name string `json:&quot;stu_name&quot;`
    ID   string `json:&quot;stu_id&quot;`
    Age  int    `json:&quot;-&quot;`
&#125;

func main() &#123;
    buf, _ := json.Marshal(Stu&#123;&quot;Tom&quot;, &quot;t001&quot;, 18&#125;)
    fmt.Printf(&quot;%s\n&quot;, buf)
&#125;

这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; stu_name, ID -&gt; stu_id，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。
</code></pre>
<ol start="12">
<li>如何判断 2 个字符串切片（slice) 是相等的？</li>
</ol>
<pre><code class="go">go 语言中可以使用反射 reflect.DeepEqual(a, b) 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。
通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。

func StringSliceEqualBCE(a, b []string) bool &#123;
    if len(a) != len(b) &#123;
        return false
    &#125;

    if (a == nil) != (b == nil) &#123;
        return false
    &#125;

    b = b[:len(a)]
    for i, v := range a &#123;
        if v != b[i] &#123;
            return false
        &#125;
    &#125;

    return true
&#125;
</code></pre>
<ol start="13">
<li>字符串打印时，%v 和 %+v 的区别</li>
</ol>
<pre><code class="go">%v 和 %+v 都可以用来打印 struct 的值，区别在于 %v 仅打印各个字段的值，%+v 还会打印各个字段的名称。

type Stu struct &#123;
    Name string
&#125;

func main() &#123;
    fmt.Printf(&quot;%v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Tom&#125;
    fmt.Printf(&quot;%+v\n&quot;, Stu&#123;&quot;Tom&quot;&#125;) // &#123;Name:Tom&#125;
&#125;

但如果结构体定义了 String() 方法，%v 和 %+v 都会调用 String() 覆盖默认值。
</code></pre>
<ol start="14">
<li>Go 语言中如何表示枚举值(enums)？</li>
</ol>
<pre><code class="go">通常使用常量(const) 来表示枚举值。

type StuType int32

const (
    Type1 StuType = iota
    Type2
    Type3
    Type4
)

func main() &#123;
    fmt.Println(Type1, Type2, Type3, Type4) // 0, 1, 2, 3
&#125;
</code></pre>
<ol start="15">
<li>空 struct{} 的用途</li>
</ol>
<pre><code class="go">使用空结构体 `struct&#123;&#125;` 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。

比如使用 map 表示集合时，只关注 key，value 可以使用 struct&#123;&#125; 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。

type Set map[string]struct&#123;&#125;

func main() &#123;
    set := make(Set)

    for _, item := range []string&#123;&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125; &#123;
        set[item] = struct&#123;&#125;&#123;&#125;
    &#125;
    fmt.Println(len(set)) // 3
    if _, ok := set[&quot;A&quot;]; ok &#123;
        fmt.Println(&quot;A exists&quot;) // A exists
    &#125;
&#125;


再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct&#123;&#125; 代替。
func main() &#123;
    ch := make(chan struct&#123;&#125;, 1)
    go func() &#123;
        &lt;-ch
        // do something
    &#125;()
    ch &lt;- struct&#123;&#125;&#123;&#125;
    // ...
&#125;

再比如，声明只包含方法的结构体。
type Lamp struct&#123;&#125;

func (l Lamp) On() &#123;
        println(&quot;On&quot;)

&#125;
func (l Lamp) Off() &#123;
        println(&quot;Off&quot;)
&#125;
</code></pre>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ol>
<li>init() 函数是什么时候执行的</li>
</ol>
<pre><code class="go">init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。

每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。

一句话总结： import –&gt; const –&gt; var –&gt; init() –&gt; main()

package main

import &quot;fmt&quot;

func init()  &#123;
    fmt.Println(&quot;init1:&quot;, a)
&#125;

func init()  &#123;
    fmt.Println(&quot;init2:&quot;, a)
&#125;

var a = 10
const b = 100

func main() &#123;
    fmt.Println(&quot;main:&quot;, a)
&#125;
// 执行结果
// init1: 10
// init2: 10
// main: 10
</code></pre>
<ol start="2">
<li>Go 语言的局部变量分配在栈上还是堆上？</li>
</ol>
<pre><code class="go">由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。

func foo() *int &#123;
    v := 11
    return &amp;v
&#125;

func main() &#123;
    m := foo()
    println(*m) // 11
&#125;

foo() 函数中，如果 v 分配在栈上，foo 函数返回时，&amp;v 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。
</code></pre>
<ol start="3">
<li>2 个 interface 可以比较吗？</li>
</ol>
<pre><code class="go">Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况

- 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
- 类型 T 相同，且对应的值 V 相等。


type Stu struct &#123;
    Name string
&#125;

type StuInt interface&#123;&#125;

func main() &#123;
    var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125;
    var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125;
    fmt.Println(stu1 == stu2) // false
    fmt.Println(stu3 == stu4) // true
&#125;
stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。
stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。
</code></pre>
<ol start="4">
<li>两个 nil 可能不相等吗？</li>
</ol>
<pre><code class="go">可能。

接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。

两个接口值比较时，会先比较 T，再比较 V。
接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。

func main() &#123;
    var p *int = nil
    var i interface&#123;&#125; = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
&#125;
上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。

但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。
</code></pre>
<ol start="5">
<li>简述 Go 语言GC(垃圾回收)的工作原理</li>
</ol>
<p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，<strong>Go 语言采用的是标记清除算法</strong>。并在此基础上使用了<strong>三色标记法和写屏障技术</strong>，提高了效率。</p>
<p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p>
<ul>
<li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li>
<li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。<br>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</li>
</ul>
<p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p>
<ul>
<li>白色：不确定对象。</li>
<li>灰色：存活对象，子对象待处理。</li>
<li>黑色：存活对象。<br>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</li>
</ul>
<p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以<strong>三色标记法是一个 false negative（假阴性）的算法</strong>。</p>
<p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p>
<pre><code class="go">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)
</code></pre>
<p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p>
<pre><code class="go">A (黑) -&gt; B (灰) -&gt; C (白) 
  ↓
 D (白)
</code></pre>
<p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p>
<p>一次完整的 GC 分为四个阶段：<br>1） 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)<br>2） 使用三色标记法标记（Marking, 并发）<br>3） 标记结束(Mark Termination，需 STW)，关闭写屏障。<br>4） 清理(Sweeping, 并发)</p>
<ol start="6">
<li>函数返回局部变量的指针是否安全？</li>
</ol>
<pre><code class="go">这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。
</code></pre>
<ol start="7">
<li>非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？</li>
</ol>
<ul>
<li>一个T类型的值可以调用为*T类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型*T声明的方法。</li>
<li>反过来，一个*T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型*T自动隐式声明一个同名和同签名的方法。</li>
</ul>
<p>哪些值是不可寻址的呢？</p>
<ul>
<li>字符串中的字节；</li>
<li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li>
<li>常量；</li>
<li>包级别的函数等。<br>举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</li>
</ul>
<pre><code class="go">type T string

func (t *T) hello() &#123;
    fmt.Println(&quot;hello&quot;)
&#125;

func main() &#123;
    var t1 T = &quot;ABC&quot;
    t1.hello() // hello
    const t2 T = &quot;ABC&quot;
    t2.hello() // error: cannot call pointer method on t
&#125;
</code></pre>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><ol>
<li>无缓冲的 channel 和 有缓冲的 channel 的区别？</li>
</ol>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 银飒沓流星
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;高亚鹏
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
